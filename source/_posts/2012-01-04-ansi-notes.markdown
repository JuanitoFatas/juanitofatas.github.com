---
layout: post
title: "ANSI COMMON LISP 筆記"
date: 2012-01-04 15:45
comments: true
categories: ["Common Lisp"]
tags: lisp
published: true
---

Paul Graham在1996年所寫的---

*ANSI COMMON LISP*

有不清楚的地方，想要建議的朋友，請留言，非常謝謝。

<!--more-->

## 第一章

### page 1

#### 回傳小於n的和

``` clojure
(defun sum (n)
    (let ((s 0))
      (dotimes (i n s)
        (incf s i))))
```

### page 2

接受一個輸入n，回傳一個把n與傳入參數相加的函數

實際上這是一個詞法閉包（lexical clojure）。
在別的語言可能閉包是一個模糊的概念，但在Common Lisp的世界裡，
到處都用到了使用閉包的好處。    

``` clojure
(defun addn (n)
    #'(lambda (x)
        (+ x n)))
```

在c語言怎麼實現？你根本實現不了。    
別的語言跟你說，不要做語言實現不到的事情。    
但在LISP不一樣，你什麼都實現的了。    


### 宏

宏(Macro)：能夠自己寫程序的程序。聽起來很玄乎吧！    
有了閉包、宏以及動態型別，LISP比OOP還猛多了。

第2-13章慢慢的介紹你需要了解第17章的概念。

學完以後，你會感覺到用C++編程是多麼彆扭的事情，
因為你將知道有很多事情，在LISP中可以輕易辦到，而在C++不行。
學LISP不僅是學一門新的編程語言，也教你新的、更有威力的思考程序的方法。


### page 3

LISP的自動記憶體管理(automatic memory management)、類別型別(manifest typing)、閉包...等等。讓編程變成一件更簡單的事。    

LISP是可擴展的。    

你可以定義自己的運算元，所有的一切。    
實際上你在用LISP時，就是一直的在建立新的語言。    
你建立一個語言來解決你要解決的問題。    

大家可能聽過，什麼語言適合解決什麼樣的問題。    
但在LISP，你是把它改成適合解決這個問題的語言。    
而LISP的程序設計方式是由下而上的(bottom-up)，由下而上表示你把一個大的問題，    
分成了無數的小問題，各個擊破。當程序越來越複雜的時候，這種方式就更顯優勢。    

別的語言也可以用這種方式來解決問題，但LISP的本質就是如此，再合適不過了。    
由下而上的編程方式，也使得軟體很容易擴展及重複使用。

1980年代三個用LISP來擴展自身的程序的例子：GNU EMACS, AUTOCAD以及Interleaf。

LISP讓你不僅可以寫很複雜的程序，還可以很快的寫出來。
LISP寫出來的程序通常很短，而通常越短的程序代表你只需要花較少的時間來實現。
LISP的edit-compile-test週期很短，編起程序來像開車一樣，踩個油門就加速了。
你能感覺到，是即時的編程體驗。


### page 4


LISP更高的抽象化及互動環境改變了人們寫軟體的方式。
Rapid Prototyping（快速建型）這個名詞就是由LISP而來的。    
以前通常是寫好規格，建立原型，修改，實作。    
而LISP讓這個流程走起來非常的流暢且緊密。    

如果你沒有完全的掌握LISP，以上的東西你聽起來就像是沒有意義的吹牛一樣。

這本書不僅僅是要解釋LISP語言，更告訴你一種新的方法。    
這種新的方法逐漸取代了過去，plan-and-implement的方法。    

### page 5

過去大家總是一開始想的很周到，但還是有bug，不管你多麼會規劃，總是有bug。
因為我們是人類，人類會犯錯，會犯傻。人們傾向認為規格是周全的，照著規格做就不會有bug了。

而修復bug的代價是什麼，程序員最珍貴的，時間。    

函數式的編程讓bug只在作用的函數中產生、讓程式變短、讓有些錯誤根本不可能發生。    


### page 6

Object-oritented dynamic langauge 面相對象的動態編程語言 --- LISP


## 第二章

### page 7

#### Form(形式)

每一個Lisp系統都包含了一個互動的前台，稱之為 頂層（toplevel ）。    
你輸入 Lisp 表達式到頂層，系統顯示他們的值給你。    
 Lisp 通常用 `>` 表示頂層等待下一個輸入的提示符號。

``` clojure 
> 1
1
>
```

你在頂層輸入1，系統打印 1 回來給你。
像1，以及其它的數字，是對自己本身求值的，稱之為自身求值。

### page 8

``` clojure
> (+ 2 3)
5
```
在上面的例子中，
`+`號叫做運算元，2 跟 3 叫做函數的引數(arguments)。

前序表達式看起來很不順眼吧，但其實他是Lisp最好的事情之一。

一個表達式裡面可以有好幾個多個表達式所組成(nested)。

比如 `(/ (- 7 1) (- 4 2))`    
在中文呢就是 七減一除以四減二

### page 9

另一件美事是，LISP的表示法就這麼點東西了。

所有LISP的表達式，要麼是原子(atom)，比如1、2、3，要麼是列表(list)，或由0個或多個包含在括號內的表達式所組成的列表。

而像我們輸入 1 ，系統打印 1 回給我們就叫做求值 (evaluate)

在Lisp中， `+` 是一個函數（運算元），`(+ 2 3)`這樣的形式稱為函數調用。

我們調用 `＋` 函數，並傳入兩個引數(2跟3)給他，當作 `+` 函數的引數。

運算元這個詞比較難懂一點，非必要說運算元的時候，我們使用函數這個詞。

一、先對引數依序求值    
二、把求值後的引數傳入函數    

函數調用都是由上述的方法來做求值的。

而不是所有的運算元都是函數，但大部分是。

這算是基本的Common Lisp求值規則。

### page 10

有一個運算元不遵循這個規則，叫做 `quote` 運算元。    
`quote` 是一個特殊的運算元，有自己獨特的求值規則。    
這個規則是：什麼也不做，並返回所傳入的引數。    

Lisp提供`quote`運算元，讓表達式有一種不會被求值的方法

Lisp幾乎有所有其它語言提供的型別。

### page 11

而整數跟字串是自身求值的。

而有兩個資料型別是別的語言通常沒有的，叫做 符號 與 列表。

符號就是單詞，而Lisp是不分大小寫的。

列表由0個或多個包含在括號內的表達式所組成。

你要用列表的話，要把它quoted起來，不然Lisp會以為這是一個函數調用。

注意： `quote` 保護了整個表達式，避免了列表被求值，包括裡面的表達式。

你可以使用 `list` 函數 來創建列表。

LISP程序全都是用列表來表示的。

如果一個列表被quoted了，那麼系統會會直接回傳這個列表;

如果一個列表沒有被quoted，那麼系統會認為這是代碼，並對它求值。


### page 12

在LISP當中，有兩種方式可以表達空的列表。

`()` 或 `NIL`

NIL也是自身求值的。

函數 `cons` 是用來創建列表的。

如果 `cons` 的第二個引數是一個列表，

那麼它會回傳一個把第二個引數（一個列表）加上第一個引數在最前方的列表。

``` clojure
> (cons 'a '(b c d))
(A B C D)
```

我們在11頁所看到的 `list` 函數是一種便捷創建列表的方法，
創建一個在空的列表內加入數個東西的列表。

請看以下的例子：

``` clojure
> (cons 'a (cons 'b nil)) 
(A B)

> (list 'a 'b)
(A B)
```

Lisp 用來取出列表的元素的基本函數(Primitive Function)有 `car` 及 `cdr`。

`car` 是一個列表的 第一個元素，而 `cdr` 是第一個元素之後的所有東西。

``` clojure
>(car '(a b c))
A
>(cdr '(a b c))
(B C)
```

把 `car` 與 `cdr` 混著使用你可以取出列表中任何位置的元素。

如果你想取得第三個元素，你可以：

### page 13

``` clojure
>(car (cdr (cdr '(a b c d))))
C
```

然而，你可以用更簡單的方法完成，用 `third` 就可以了：

```clojure
> (third '(a b c d))
C
```

2.5 真假值

在Common Lisp裡，用 `T` 來表示 "真"，`t`也是自身求值的。

在Common Lisp裡，用 `NIL` 或 `()` 來表示 "假"。

注意：0不是"假"的方式。

``` clojure
> (listp 99)
NIL
> (listp '(a b c))
T
``` 

我們用函數 `null` 來判斷是不是 "假" 或 "空列表"。

用函數 `not` 來給一個引數作反相（引數若為真，回傳假; 若為假，回傳真）

``` clojure
> (null nil)
T
> (not nil)
T
```

在Common Lisp中最簡單的表達式是 `if`。

`if` 需要傳入三個引數：

`test` 表達式
`then` 表達式
`else` 表達式 (選擇性的，可寫可不寫)

如果test表達式求值的結果為真，那就會對then表達式求值，並回傳這個值。    
如果test表達式求值的結果為假，那就會對else表達式求值，並回傳這個值。

### page 14

``` clojure
>(if (listp '(a b c))
  	 (+ 1 2)
	 (+ 3 4))
3
>(if (listp 8)
  	 (+ 1 2)
	 (+ 3 4))
7
```

`if` 跟 `quote` 一樣都是特殊的運算元（有獨特的求值規則），很難用函數的方式實現，

因為函數的每一個引數都會被求值（而 `if` 則視情況對 `then` 或 `else` 表達式求值）。

`else` 表達式是選擇性的，如果沒寫預設是`NIL`。

``` clojure
> (if (listp 8)
	 (+ 2 3))
NIL
```

雖然 `t` 是"真"的預設表達法。
但其他不是 `NIL` 在邏輯的語意下都視為 "真"。

``` clojure
> (if 8 1 0)
1
```

邏輯運算元  `and`  `or`


這兩個邏輯運算元可傳入任何長度的引數，但只對需要的引數求值。

`and` 會依序對傳入的引數求值，若所有的引數都為"真"，則回傳最後一個引數。
若有一個引數為"假"（不是nil或空列表），之後的引數不會被求值，並回傳"假"。

`or` 會依序對對傳入的引數求值，只要有一個引數為"真"，則回傳此引數的求值。
若全部的引數都為"假"（nil或空列表），則回傳"假"。

這兩個運算元稱之為"宏"。

你可以用 `defun` 來定義新的函數。通常傳入3個或更多的引數：

名字、一個包含參數的列表及一個或多個表達式作為函數的本體。

我們可以這麼定義 `third` 。

### page 15

``` clojure
> (defun our-third (x)
	 (car (cdr (cdr x))))
OUR-THIRD
```

第一個引數(our-third)是我們定義的這個新函數的名字。    
第二個列表是這個函數只有一個引數，x，一個這樣用的符號又稱之為變量(variable)。    
當 變量 用來表示 函數的引數時，又叫作參數。    

第三個引數 `(car (cdr (cdr x)))` 是函數的本體。
告訴這個函數要怎麼回傳這個函數的值。

我們看過變量以後，就更容易了解什麼是符號。
符號就是變量的名字，所以使用符號的時候需要quoted它。
如果沒有quoted符號的話，會被系統當成變量，而對它求值。

你可以把函數的定義想成是Lisp表達式的通則。

``` clojure
> (> (+ 1 2) 3)
NIL
```

把這些數字用變量替換，我們可以寫一個函數，
來測試第一、二個引數的和是否大於第三個引數。

``` clojure
> (defun sum-greater (x y z)
	 (> (+ x y) z))
SUM-GREATER
> (sum-greater 1 4 3)
T 
```

